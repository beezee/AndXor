@import andxor.syntax._

@(tpes: List[String])
import scala.language.higherKinds
import scalaz.{Apply, Functor, Monoid, \/, -\/, \/-, ~>}
import scalaz.Id.Id
import scalaz.syntax.either._

trait AndXorK@{tpes.length}[F[_], @{tpes.prod}] extends AndXor {
  type Prod = @{tpes.prodK("F")}
  type Cop = @{tpes.djK("F")}
  def combine[G[_]](implicit @{tpes.paramSig(List("G", "F"), "a")}): ComposeAndXor[G, Cop, Prod] =
    new ComposeAndXor[G, Cop, Prod] {
      def mkChoose[B](f: B => Cop)(implicit d: Decidable[G]): G[B] =
        Combine.choose@{tpes.length}(@{tpes.params("a")})(f)
      def mkAlt[B](f: Cop => B)(implicit a: Alt[G]): G[B] =
        Combine.altly@{tpes.length}(@{tpes.params("a")})(f)
      def mkDivide[B](f: B => Prod)(implicit d: Divide[G]): G[B] =
        Combine.divide@{tpes.length}(@{tpes.params("a")})(f)
      def mkApply[B](f: Prod => B)(implicit a: Apply[G]): G[B] =
        Combine.apply@{tpes.length}(@{tpes.params("a")})(
          (@{tpes.params("i")}) =>
            f((@{tpes.params("i")})))
    }

  object instances {
    @{tpes.zipper(template.txt.Inj(_)).mkString("\n")}
    @{tpes.zipper(template.txt.Lift(_)).mkString("\n")}
  }

  import instances._

  val injEv = combine[Inj.Aux[Cop]#Out].choose
  def liftEv(implicit M: Monoid[Prod]): Inj[Prod, Prod] = combine[Inj.Aux[Prod]#Out].divide

  def transformP[G[_]](nt: (F ~> G)):
  AndXorK@{tpes.length}[F, @{tpes.prod}]#Prod => AndXorK@{tpes.length}[G, @{tpes.prod}]#Prod =
    (p: AndXorK@{tpes.length}[F, @{tpes.prod}]#Prod) =>
      (@{tpes.zipWithIndex.map(x => s"nt(p._${x._2 + 1})").mkString(", ")})

  def transformC[G[_]](nt: (F ~> G)):
  AndXorK@{tpes.length}[F, @{tpes.prod}]#Cop => AndXorK@{tpes.length}[G, @{tpes.prod}]#Cop =
    (p: AndXorK@{tpes.length}[F, @{tpes.prod}]#Cop) => p@{
      tpes.tail.foldRight("nt(_)")((_, a) => s"_.bimap(nt(_), ${a})").tail}

  // format: off
  def sequenceP(prod: Prod)(A: Apply[F]): F[AndXorK@{tpes.length}[Id, @{tpes.prod}]#Prod] = {
    val (@{tpes.params("a")}) = prod@{
    tpes.paramList("a").tail.foldLeft(
      s"""\n     A.map(a0)(((${tpes.paramSig("i")}) =>\n    (${tpes.params("i")})).curried)""")(
        (a, e) => s"\n    A.ap(${e})(${a})")}
  }
  // format: on
}

object AndXorK@{tpes.length} {

  def apply[F[_], @{tpes.prod}]: AndXorK@{tpes.length}[F, @{tpes.prod}] =
    new AndXorK@{tpes.length}[F, @{tpes.prod}] {}
}

trait AndXorF@{tpes.length}[@{tpes.prod}] {
  type Repr[F[_]] = AndXorK@{tpes.length}[F, @{tpes.prod}]
  def apply[F[_]]: Repr[F] =
    new AndXorK@{tpes.length}[F, @{tpes.prod}] {}
}

object AndXorF@{tpes.length} {
  def apply[@{tpes.prod}]: AndXorF@{tpes.length}[@{tpes.prod}] =
    new AndXorF@{tpes.length}[@{tpes.prod}] {}
}

trait AndXor@{tpes.length}[@{tpes.prod}] extends
AndXorK@{tpes.length}[Id, @{tpes.prod}]

object AndXor@{tpes.length} {
  def apply[@{tpes.prod}]: AndXor@{tpes.length}[@{tpes.prod}] =
    new AndXor@{tpes.length}[@{tpes.prod}] {}
}
