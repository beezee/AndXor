@import ldr.syntax._

@(tpes: List[String])
import scala.language.higherKinds
import scalaz.{Apply, Monoid, \/, ~>}
import scalaz.Id.Id
import scalaz.syntax.either._

trait LDRK@{tpes.length}[F[_], @{tpes.prod}] extends LDR {
  type Prod = @{tpes.prodK("F")}
  type Cop = @{tpes.djK("F")}
  def combine[G[_]](implicit @{tpes.paramSig(List("G", "F"), "a")}): ComposeLDR[G, Cop, Prod] =
    new ComposeLDR[G, Cop, Prod] {
      def mkChoose[B](f: B => Cop)(implicit d: Decidable[G]): G[B] =
        Combine.choose@{tpes.length}(@{tpes.params("a")})(f)
      def mkAlt[B](f: Cop => B)(implicit a: Alt[G]): G[B] =
        Combine.altly@{tpes.length}(@{tpes.params("a")})(f)
      def mkDivide[B](f: B => Prod)(implicit d: Divide[G]): G[B] =
        Combine.divide@{tpes.length}(@{tpes.params("a")})(f)
      def mkApply[B](f: Prod => B)(implicit a: Apply[G]): G[B] =
        Combine.apply@{tpes.length}(@{tpes.params("a")})(
          (@{tpes.params("i")}) =>
            f((@{tpes.params("i")})))
    }

  object instances {
    @{tpes.zipper(template.txt.Inj(_)).mkString("\n")}
    @{tpes.zipper(template.txt.Lift(_)).mkString("\n")}
  }

  import instances._

  val injEv = combine[Inj.Aux[Cop]#Out].choose
  def liftEv(implicit M: Monoid[Prod]): Inj[Prod, Prod] = combine[Inj.Aux[Prod]#Out].divide

  def transformP[G[_]](nt: (F ~> G)):
  LDRK@{tpes.length}[F, @{tpes.prod}]#Prod => LDRK@{tpes.length}[G, @{tpes.prod}]#Prod =
    (p: LDRK@{tpes.length}[F, @{tpes.prod}]#Prod) =>
      (@{tpes.zipWithIndex.map(x => s"nt(p._${x._2 + 1})").mkString(", ")})

  def transformC[G[_]](nt: (F ~> G)):
  LDRK@{tpes.length}[F, @{tpes.prod}]#Cop => LDRK@{tpes.length}[G, @{tpes.prod}]#Cop =
    (p: LDRK@{tpes.length}[F, @{tpes.prod}]#Cop) => p@{
      tpes.tail.foldRight("nt(_)")((_, a) => s"_.bimap(nt(_), ${a})").tail}
}

object LDRK@{tpes.length} {

  def apply[F[_], @{tpes.prod}]: LDRK@{tpes.length}[F, @{tpes.prod}] =
    new LDRK@{tpes.length}[F, @{tpes.prod}] {}
}

trait LDRF@{tpes.length}[@{tpes.prod}] {
  type Repr[F[_]] = LDRK@{tpes.length}[F, @{tpes.prod}]
  def apply[F[_]]: Repr[F] =
    new LDRK@{tpes.length}[F, @{tpes.prod}] {}
}

object LDRF@{tpes.length} {
  def apply[@{tpes.prod}]: LDRF@{tpes.length}[@{tpes.prod}] =
    new LDRF@{tpes.length}[@{tpes.prod}] {}
}

trait LDR@{tpes.length}[@{tpes.prod}] extends
LDRK@{tpes.length}[Id, @{tpes.prod}]

object LDR@{tpes.length} {
  def apply[@{tpes.prod}]: LDR@{tpes.length}[@{tpes.prod}] =
    new LDR@{tpes.length}[@{tpes.prod}] {}
}
